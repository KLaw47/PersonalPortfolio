// Portfolio ERD - dbdiagram.io / DBML
// Personal portfolio site with projects, blog posts, and tags.
// `users` conceptually represents Django's auth.User model.

Table users {
  id         int          [pk, increment] // Django auth_user.id
  username   varchar(150) [not null, unique]
  email      varchar(254) [not null]
  created_at timestamp
  updated_at timestamp
}

Table projects {
  id          int          [pk, increment]
  user_id     int          [not null, ref: > users.id]
  title       varchar(200) [not null]
  slug        varchar(200) [not null, unique]
  summary     text                      // short card blurb
  description text                      // long "what I learned" content
  live_url    varchar(255)              // deployed project link
  repo_url    varchar(255)              // GitHub or other repo
  created_at  timestamp
  updated_at  timestamp
}

Table blog_posts {
  id           int          [pk, increment]
  author_id    int          [not null, ref: > users.id]
  project_id   int          [ref: > projects.id] // nullable: not every post is tied to a project
  title        varchar(200) [not null]
  slug         varchar(200) [not null, unique]
  excerpt      text                      // optional short summary for listing pages
  content      text          [not null]  // full post body (Markdown/HTML)
  status       varchar(20)   [not null]  // 'draft' or 'published'
  published_at timestamp                 // null when still a draft / never published
  created_at   timestamp
  updated_at   timestamp
}

Table tags {
  id         int         [pk, increment]
  name       varchar(50) [not null, unique]
  slug       varchar(50) [not null, unique]
  created_at timestamp
  updated_at timestamp
}

// Join table for many-to-many: projects <-> tags
Table project_tags {
  project_id int [not null, ref: > projects.id]
  tag_id     int [not null, ref: > tags.id]

  indexes {
    (project_id, tag_id) [pk] // composite primary key
  }
}

// Join table for many-to-many: blog_posts <-> tags
Table blogpost_tags {
  blogpost_id int [not null, ref: > blog_posts.id]
  tag_id      int [not null, ref: > tags.id]

  indexes {
    (blogpost_id, tag_id) [pk] // composite primary key
  }
}